use anawt::{AnawtTorrentStatus, InfoHash, TorrentState};
use iced::{
    Length, Subscription, Task,
    widget::{Column, button, image, row, svg, text},
};
use tokio::sync::watch;
use tracing::info;

use crate::{
    db::{Content, Index, IndexTag, comments::Topic, index::NovelTag},
    hash::Hash,
    helpers::SanitizedString,
    ui::{
        AppState, Message,
        icons::{CHAT_ICON, SEEN_ICON, UNSEEN_ICON},
        views::{
            View, ViewMessage, add_chapter::AddNovelChapterView, image_viewer::ImageViewerView,
            post::PostView,
        },
    },
};

#[derive(Debug, Clone)]
pub struct NovelView {
    novel: Index<NovelTag>,
    chapters: Vec<Content<NovelTag>>,
    pub torrents: Vec<Option<watch::Receiver<AnawtTorrentStatus>>>,
}

#[derive(Debug, Clone)]
pub enum NovelMessage {
    ContentLoaded(Vec<Content<NovelTag>>),
    LoadedTorrentWatcher(Vec<Option<watch::Receiver<AnawtTorrentStatus>>>),
    ReloadTorrents,
    DownloadTorrentAndReload { magnet: String, path: String },
    UpdateProgress(usize, usize, f32),
    TorrentStatusUpdated,
}

impl From<NovelMessage> for Message {
    fn from(m: NovelMessage) -> Self {
        Message::ViewMessage(ViewMessage::Novel(m))
    }
}

impl NovelView {
    pub fn new(novel: Index<NovelTag>) -> Self {
        Self {
            novel,
            chapters: vec![],
            torrents: Vec::new(),
        }
    }

    pub fn on_enter(state: &mut AppState) -> Task<Message> {
        if let View::Novel(v) = &mut state.view {
            if let Some(repositories) = &state.repositories {
                let repositories = repositories.clone();
                let novel_hash = v.novel.hash().clone();
                return Task::future(async move {
                    let chapters = repositories.index().await.get_contents(novel_hash).await;
                    NovelMessage::ContentLoaded(chapters).into()
                });
            }
        }
        Task::none()
    }

    pub fn subscription(&self) -> iced::Subscription<Message> {
        Subscription::none()
    }

    pub fn view(&self, state: &AppState) -> iced::Element<Message> {
        let mut column: Vec<iced::Element<Message>> = vec![text(self.novel.title().clone()).into()];

        column.push(
            button(text("Add Chapter"))
                .on_press(Message::ChangeView(View::AddChapter(
                    AddNovelChapterView::new(self.novel.clone()),
                )))
                .into(),
        );

        for i in 0..self.chapters.len() {
            let chapter = &self.chapters[i];
            let rx = self.torrents[i].as_ref();
            enum ContentState {
                Downloading(f64),
                Download,
                Ready,
            }
            let select_message: ContentState = match rx {
                Some(rx) => {
                    let status = rx.borrow();

                    match status.state {
                        TorrentState::Finished | TorrentState::Seeding => ContentState::Ready,
                        _ => ContentState::Downloading(status.progress),
                    }
                }
                None => ContentState::Download,
            };

            //         text(format!("Downloading: {:.1}", status.progress * 100.0))
            for (j, e) in chapter.entries().iter().enumerate() {
                column.push(
                    row![
                        button(text(e.title.clone())).on_press_maybe(match select_message {
                            ContentState::Downloading(_) => None,
                            ContentState::Download => Some(
                                NovelMessage::DownloadTorrentAndReload {
                                    magnet: chapter.magnet_link.clone().0,
                                    path: format!(
                                        "./data/{}/{}/{}",
                                        NovelTag::TAG,
                                        SanitizedString::new(self.novel.title()).as_str(),
                                        chapter.signature().as_base64_url()
                                    ),
                                }
                                .into()
                            ),
                            ContentState::Ready => Some(Message::ChangeView(View::ImageViewer(
                                ImageViewerView::new(
                                    format!(
                                        "./data/{}/{}/{}/{}",
                                        NovelTag::TAG,
                                        SanitizedString::new(self.novel.title()).as_str(),
                                        chapter.signature().as_base64_url(),
                                        chapter.entries()[j].path
                                    )
                                    .into(),
                                )
                            ))),
                        }),
                        match select_message {
                            ContentState::Downloading(p) => {
                                text(format!("Downloading: {:.1}", p * 100.0))
                            }
                            ContentState::Download => text("---"),
                            ContentState::Ready => text("R"),
                        },
                        if e.progress < 1.0 {
                            button(
                                svg(svg::Handle::from_memory(UNSEEN_ICON))
                                    .height(Length::Fixed(32.0))
                                    .width(Length::Fixed(32.0)),
                            )
                            .on_press(NovelMessage::UpdateProgress(j, i, 1.0).into())
                        } else {
                            button(
                                svg(svg::Handle::from_memory(SEEN_ICON))
                                    .height(Length::Fixed(32.0))
                                    .width(Length::Fixed(32.0)),
                            )
                            .on_press(NovelMessage::UpdateProgress(j, i, 0.0).into())
                        },
                        button(
                            svg(svg::Handle::from_memory(CHAT_ICON))
                                .height(Length::Fixed(32.0))
                                .width(Length::Fixed(32.0))
                        )
                        .on_press(Message::ChangeView(View::Post(
                            PostView::new(Topic::from_entry(&self.novel, e.enumeration))
                        )))
                    ]
                    .into(),
                );
            }
        }

        Column::from_vec(column).into()
    }

    pub fn update(m: NovelMessage, state: &mut AppState) -> Task<Message> {
        if let View::Novel(v) = &mut state.view {
            match m {
                NovelMessage::ContentLoaded(chapters) => {
                    v.torrents = vec![None; chapters.len()];
                    v.chapters = chapters;
                    return Task::done(NovelMessage::ReloadTorrents.into());
                }
                NovelMessage::UpdateProgress(j, i, p) => {
                    v.chapters[i].update_entry_progress(j, p);
                }
                NovelMessage::LoadedTorrentWatcher(watchers) => {
                    info!("Loaded torrent watcher");
                    v.torrents = watchers;
                }
                NovelMessage::DownloadTorrentAndReload { magnet, path } => {
                    info!("Downloading and reloading: {}", magnet);
                    return Task::done(Message::DownloadTorrent { magnet, path })
                        .chain(Task::done(NovelMessage::ReloadTorrents.into()));
                }
                NovelMessage::ReloadTorrents => {
                    info!("Reloading torrents");
                    let torrent_client = state.torrent_client.clone();
                    if let Some(torrent_client) = torrent_client {
                        let chapters = v.chapters.clone();
                        let len = chapters.len();
                        return Task::future(async move {
                            let mut watchers = vec![None; len];

                            for (i, chapter) in chapters.iter().enumerate() {
                                let info_hash = match InfoHash::from_magnet(&chapter.magnet_link.0)
                                {
                                    Ok(info_hash) => info_hash,
                                    Err(_) => continue, // TODO: Invalid magnet, issue chapter deletion
                                };
                                let rx = torrent_client.subscribe_torrent(info_hash).await;
                                watchers[i] = rx;
                            }

                            NovelMessage::LoadedTorrentWatcher(watchers).into()
                        });
                    }
                }
                NovelMessage::TorrentStatusUpdated => {}
            }
        }

        Task::none()
    }
}
